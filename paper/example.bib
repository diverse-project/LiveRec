@inproceedings{10.1145/3426428.3426919,
    author = {Niephaus, Fabio and Rein, Patrick and Edding, Jakob and Hering, Jonas and K\"{o}nig, Bastian and Opahle, Kolya and Scordialo, Nico and Hirschfeld, Robert},
    title = {Example-Based Live Programming for Everyone: Building Language-Agnostic Tools for Live Programming with LSP and GraalVM},
    year = {2020},
    isbn = {9781450381789},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3426428.3426919},
    doi = {10.1145/3426428.3426919},
    abstract = {Our community has explored various approaches to improve the programming experience. Although many of them, such as Example-Based Live Programming (ELP), have shown to be effective, they are still not widespread in conventional programming environments. A reason for that is the effort required to provide sophisticated tools that rely on run-time information. To target multiple language ecosystems, it is often necessary to implement the same concepts, but for different languages and runtimes. Two emerging technologies present an opportunity to reduce this effort significantly: the Language Server Protocol (LSP) and language implementation frameworks such as GraalVM's Truffle. In this paper, we show how an ELP system can be built in a language-agnostic way by leveraging these two technologies. Based on our approach, we implemented the Babylonian Programming system, an ELP system that has previously only been implemented for exploratory ecosystems. Our system, on the other hand, brings ELP for all languages supported by the GraalVM to Visual Studio Code (VS Code). Moreover, we outline what a language-agnostic infrastructure needs to provide and how the LSP could be extended to support ELP also independently from programming environments. Further, we demonstrate how our approach enables the use of ELP in the context of polyglot programming. We illustrate the consequences of our approach by discussing its advantages and limitations and by comparing the features of our system to other ELP systems. Moreover, we give an outlook of how tools that rely on run-time information could be built in the future. This in turn might motivate future tool builders and researchers to consider implementing more tools in a language-agnostic way from the start to make them available to a broader audience.},
    booktitle = {Proceedings of the 2020 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
    pages = {1–17},
    numpages = {17},
    keywords = {GraalVM, Live Programming, Visual Studio Code, Exploratory Programming, Language Server Protocol, Truffle},
    location = {Virtual, USA},
    series = {Onward! 2020}
}

@article{10.1145/1052883.1052894,
author = {Edwards, Jonathan},
title = {Example Centric Programming},
year = {2004},
issue_date = {December 2004},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {12},
issn = {0362-1340},
url = {https://doi.org/10.1145/1052883.1052894},
doi = {10.1145/1052883.1052894},
abstract = {Programmers tend to understand programs by thinking of concrete examples. Example Centric Programming seeks to add IDE support for examples throughout the process of programming. Instead of programmers interpreting examples in their head, the examples are written down and the IDE interprets them automatically. Advanced UI techniques are used to present the results closely integrated with the code. Traditionally distinct programming tools (the editor, Read-Eval-Print-Loop, debugger, and test runner) are unified into a single tool that might be called an example-enlightened editor. This is expected to benefit a wide spectrum of programming activities, for both novice and experienced programmers. Some novel methods for testing and development are made possible. In the longer term, example centrism has implications for the design of future programming languages. A prototype has been implemented for Java in Eclipse.},
journal = {SIGPLAN Not.},
month = {dec},
pages = {84–91},
numpages = {8},
keywords = {integrated development, debugging, environment, examples, unit testing, eclipse}
}

@inproceedings{10.1145/2509578.2509585,
author = {McDirmid, Sean},
title = {Usable Live Programming},
year = {2013},
isbn = {9781450324724},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2509578.2509585},
doi = {10.1145/2509578.2509585},
abstract = {Programming today involves code editing mixed with bouts of debugging to get feedback on code execution. For programming to be more fluid, editing and debugging should occur concurrently as live programming. This paper describes how live execution feedback can be woven into the editor by making places in program execution, not just code, navigable so that evaluation results can be probed directly within the code editor. A pane aside the editor also traces execution with entries that are similarly navigable, enabling quick problem diagnosis. Both probes and traces are refreshed continuously during editing, and are easily configured based on debugging needs. We demonstrate the usefulness of this live programming experience with a prototype.},
booktitle = {Proceedings of the 2013 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \& Software},
pages = {53–62},
numpages = {10},
keywords = {debugging, live programming},
location = {Indianapolis, Indiana, USA},
series = {Onward! 2013}
}

@inproceedings{10.1145/1297027.1297067,
author = {Pothier, Guillaume and Tanter, \'{E}ric and Piquer, Jos\'{e}},
title = {Scalable Omniscient Debugging},
year = {2007},
isbn = {9781595937865},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1297027.1297067},
doi = {10.1145/1297027.1297067},
abstract = {Omniscient debuggers make it possible to navigate backwards in time within a program execution trace, drastically improving the task of debugging complex applications. Still, they are mostly ignored in practice due to the challenges raised by the potentially huge size of the execution traces. This paper shows that omniscient debugging can be realistically realized through the use of different techniques addressing efficiency, scalability and usability. We present TOD, a portable Trace-Oriented Debugger for Java, which combines an efficient instrumentation for event generation, a specialized distributed database for scalable storage and efficient querying, support for partial traces in order to reduce the trace volume to relevant events, and innovative interface components for interactive trace navigation and analysis in the development environment. Provided a reasonable infrastructure, the performance of TOD allows a responsive debugging experience in the face of large programs.},
booktitle = {Proceedings of the 22nd Annual ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications},
pages = {535–552},
numpages = {18},
keywords = {partial traces, omniscient debugging, specialized distributed database, scalability, interface components, execution traces},
location = {Montreal, Quebec, Canada},
series = {OOPSLA '07}
}

@article{10.1145/1297105.1297067,
author = {Pothier, Guillaume and Tanter, \'{E}ric and Piquer, Jos\'{e}},
title = {Scalable Omniscient Debugging},
year = {2007},
issue_date = {October 2007},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {42},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1297105.1297067},
doi = {10.1145/1297105.1297067},
abstract = {Omniscient debuggers make it possible to navigate backwards in time within a program execution trace, drastically improving the task of debugging complex applications. Still, they are mostly ignored in practice due to the challenges raised by the potentially huge size of the execution traces. This paper shows that omniscient debugging can be realistically realized through the use of different techniques addressing efficiency, scalability and usability. We present TOD, a portable Trace-Oriented Debugger for Java, which combines an efficient instrumentation for event generation, a specialized distributed database for scalable storage and efficient querying, support for partial traces in order to reduce the trace volume to relevant events, and innovative interface components for interactive trace navigation and analysis in the development environment. Provided a reasonable infrastructure, the performance of TOD allows a responsive debugging experience in the face of large programs.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {535–552},
numpages = {18},
keywords = {omniscient debugging, partial traces, scalability, specialized distributed database, execution traces, interface components}
}
