
@unpublished{MakingMethodsLive,
  author = {Gilad Bracha},
  note   = {Online: \url{https://gbracha.blogspot.com/2013/04/making-methods-live.html}},
  title  = {Making Methods Live},
  year   = {2013}
}

@unpublished{DebugMode,
  author = {Gilad Bracha},
  note   = {Online: \url{https://gbracha.blogspot.com/2012/11/debug-mode-is-only-mode.html}},
  title  = {Debug Mode is the Only Mode},
  year   = {2012}
}

@inproceedings{Newspeak,
  author       = {Gilad Bracha and
                  Peter von der Ah{\'{e}} and
                  Vassili Bykov and
                  Yaron Kashai and
                  William Maddox and
                  Eliot Miranda},
  editor       = {Theo D'Hondt},
  title        = {Modules as Objects in Newspeak},
  booktitle    = {{ECOOP} 2010 - Object-Oriented Programming, 24th European Conference,
                  Maribor, Slovenia, June 21-25, 2010. Proceedings},
  series       = {Lecture Notes in Computer Science},
  volume       = {6183},
  pages        = {405--428},
  publisher    = {Springer},
  year         = {2010},
  doi          = {10.1007/978-3-642-14107-2\_20},
  timestamp    = {Tue, 14 May 2019 10:00:54 +0200},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}



@unpublished{InventingOnPrinciple,
  author = {Bret Victor},
  note   = {Online: \url{https://www.youtube.com/watch?v=PUv66718DII}},
  title  = {Inventing on Principle},
  year   = {2012}
}

@unpublished{JDI,
  author = {Oracle},
  note   = {Online: \url{https://docs.oracle.com/javase/8/docs/jdk/api/jpda/jdi/index.html}},
  title  = {Java Debug Interface},
  year   = {2023}
}

@unpublished{DAP,
  author = {Microsoft},
  note   = {Online: \url{https://microsoft.github.io/debug-adapter-protocol/}},
  title  = {Debug Adapter Protocol},
  year   = {2021}
}

@phdthesis{Hancock03,
  author = {C. Hancock and M. Resnick},
  title  = {Real-time programming and the big ideas of computational literacy},
  year   = {2003},
  school  = {Massachusetts Institute of Technology},
  url = {https://dspace.mit.edu/handle/1721.1/61549}
}

@inproceedings{LiveLiterals,
  author          = {Tijs van der Storm and Felienne Hermans},
  booktitle       = {LIVE'16},
  title           = {Live Literals},
  year            = {2016},
  note            = {Online: \url{https://www.cwi.nl/~storm/livelit/livelit.html}},
}

@ARTICLE {Masinter81,
author = {L. Masinter and W. Teitelman},
journal = {Computer},
title = {The Interlisp Programming Environment},
year = {1981},
volume = {14},
number = {04},
issn = {1558-0814},
pages = {25-33},
keywords = {null},
doi = {10.1109/C-M.1981.220410},
publisher = {IEEE Computer Society},
address = {Los Alamitos, CA, USA},
month = {apr}
}

@book{Goldberg80,
author = {Goldberg, Adele},
title = {SMALLTALK-80:  The Interactive Programming Environment},
year = {1984},
isbn = {0201113724},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA}
}

@unpublished{LiveProgHist13,
  author = {Unkown},
  note   = {Online: \url{https://liveprogramming.github.io/liveblog/2013/01/a-history-of-live-programming/}},
  title  = {A History of Live Programming},
  year   = {2013}
}


@article{Sandewall78,
author = {Sandewall, Erik},
title = {Programming in an Interactive Environment: The ``Lisp'' Experience},
year = {1978},
issue_date = {March 1978},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {10},
number = {1},
issn = {0360-0300},
url = {https://doi.org/10.1145/356715.356719},
doi = {10.1145/356715.356719},
journal = {ACM Comput. Surv.},
month = mar,
pages = {35–71},
numpages = {37}
}


@article{tanimoto90,
  author     = {Tanimoto, Steven L.},
  title      = {VIVA: A Visual Language for Image Processing},
  year       = {1990},
  issue_date = {June, 1990},
  publisher  = {Academic Press, Inc.},
  address    = {USA},
  volume     = {1},
  number     = {2},
  issn       = {1045-926X},
  url        = {https://doi.org/10.1016/S1045-926X(05)80012-6},
  doi        = {10.1016/S1045-926X(05)80012-6},
  journal    = {J. Vis. Lang. Comput.},
  month      = {jun},
  pages      = {127–139},
  numpages   = {13}
}

@INPROCEEDINGS{TanimotoLevels,
  author={Tanimoto, Steven L.},
  booktitle={2013 1st International Workshop on Live Programming (LIVE)}, 
  title={A perspective on the evolution of live programming}, 
  year={2013},
  volume={},
  number={},
  pages={31-34},
  doi={10.1109/LIVE.2013.6617346}
}


@inproceedings{ExampleBasedGraalVM,
    author = {Niephaus, Fabio and Rein, Patrick and Edding, Jakob and Hering, Jonas and K\"{o}nig, Bastian and Opahle, Kolya and Scordialo, Nico and Hirschfeld, Robert},
    title = {Example-Based Live Programming for Everyone: Building Language-Agnostic Tools for Live Programming with LSP and GraalVM},
    year = {2020},
    isbn = {9781450381789},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3426428.3426919},
    doi = {10.1145/3426428.3426919},
    abstract = {Our community has explored various approaches to improve the programming experience. Although many of them, such as Example-Based Live Programming (ELP), have shown to be effective, they are still not widespread in conventional programming environments. A reason for that is the effort required to provide sophisticated tools that rely on run-time information. To target multiple language ecosystems, it is often necessary to implement the same concepts, but for different languages and runtimes. Two emerging technologies present an opportunity to reduce this effort significantly: the Language Server Protocol (LSP) and language implementation frameworks such as GraalVM's Truffle. In this paper, we show how an ELP system can be built in a language-agnostic way by leveraging these two technologies. Based on our approach, we implemented the Babylonian Programming system, an ELP system that has previously only been implemented for exploratory ecosystems. Our system, on the other hand, brings ELP for all languages supported by the GraalVM to Visual Studio Code (VS Code). Moreover, we outline what a language-agnostic infrastructure needs to provide and how the LSP could be extended to support ELP also independently from programming environments. Further, we demonstrate how our approach enables the use of ELP in the context of polyglot programming. We illustrate the consequences of our approach by discussing its advantages and limitations and by comparing the features of our system to other ELP systems. Moreover, we give an outlook of how tools that rely on run-time information could be built in the future. This in turn might motivate future tool builders and researchers to consider implementing more tools in a language-agnostic way from the start to make them available to a broader audience.},
    booktitle = {Proceedings of the 2020 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
    pages = {1–17},
    numpages = {17},
    keywords = {GraalVM, Live Programming, Visual Studio Code, Exploratory Programming, Language Server Protocol, Truffle},
    location = {Virtual, USA},
    series = {Onward! 2020}
}

@inproceedings{GraalVM,
  author       = {Thomas W{\"{u}}rthinger},
  editor       = {Walter Binder and
                  Erik Ernst and
                  Achille Peternier and
                  Robert Hirschfeld},
  title        = {Graal and truffle: modularity and separation of concerns as cornerstones
                  for building a multipurpose runtime},
  booktitle    = {13th International Conference on Modularity, {MODULARITY} '14, Lugano,
                  Switzerland, April 22-26, 2014},
  pages        = {3--4},
  publisher    = {{ACM}},
  year         = {2014},
  url          = {https://doi.org/10.1145/2584469.2584663},
  doi          = {10.1145/2584469.2584663},
  timestamp    = {Tue, 21 Mar 2023 21:01:43 +0100},
  biburl       = {https://dblp.org/rec/conf/aosd/Wurthinger14.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}


@article{ExampleCentric,
author = {Edwards, Jonathan},
title = {Example Centric Programming},
year = {2004},
issue_date = {December 2004},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {12},
issn = {0362-1340},
url = {https://doi.org/10.1145/1052883.1052894},
doi = {10.1145/1052883.1052894},
abstract = {Programmers tend to understand programs by thinking of concrete examples. Example Centric Programming seeks to add IDE support for examples throughout the process of programming. Instead of programmers interpreting examples in their head, the examples are written down and the IDE interprets them automatically. Advanced UI techniques are used to present the results closely integrated with the code. Traditionally distinct programming tools (the editor, Read-Eval-Print-Loop, debugger, and test runner) are unified into a single tool that might be called an example-enlightened editor. This is expected to benefit a wide spectrum of programming activities, for both novice and experienced programmers. Some novel methods for testing and development are made possible. In the longer term, example centrism has implications for the design of future programming languages. A prototype has been implemented for Java in Eclipse.},
journal = {SIGPLAN Not.},
month = {dec},
pages = {84–91},
numpages = {8},
keywords = {integrated development, debugging, environment, examples, unit testing, eclipse}
}

@inproceedings{UsableLiveProgramming,
author = {McDirmid, Sean},
title = {Usable Live Programming},
year = {2013},
isbn = {9781450324724},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2509578.2509585},
doi = {10.1145/2509578.2509585},
abstract = {Programming today involves code editing mixed with bouts of debugging to get feedback on code execution. For programming to be more fluid, editing and debugging should occur concurrently as live programming. This paper describes how live execution feedback can be woven into the editor by making places in program execution, not just code, navigable so that evaluation results can be probed directly within the code editor. A pane aside the editor also traces execution with entries that are similarly navigable, enabling quick problem diagnosis. Both probes and traces are refreshed continuously during editing, and are easily configured based on debugging needs. We demonstrate the usefulness of this live programming experience with a prototype.},
booktitle = {Proceedings of the 2013 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \& Software},
pages = {53–62},
numpages = {10},
keywords = {debugging, live programming},
location = {Indianapolis, Indiana, USA},
series = {Onward! 2013}
}

@inproceedings{ScalableOmniscient,
author = {Pothier, Guillaume and Tanter, \'{E}ric and Piquer, Jos\'{e}},
title = {Scalable Omniscient Debugging},
year = {2007},
isbn = {9781595937865},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1297027.1297067},
doi = {10.1145/1297027.1297067},
abstract = {Omniscient debuggers make it possible to navigate backwards in time within a program execution trace, drastically improving the task of debugging complex applications. Still, they are mostly ignored in practice due to the challenges raised by the potentially huge size of the execution traces. This paper shows that omniscient debugging can be realistically realized through the use of different techniques addressing efficiency, scalability and usability. We present TOD, a portable Trace-Oriented Debugger for Java, which combines an efficient instrumentation for event generation, a specialized distributed database for scalable storage and efficient querying, support for partial traces in order to reduce the trace volume to relevant events, and innovative interface components for interactive trace navigation and analysis in the development environment. Provided a reasonable infrastructure, the performance of TOD allows a responsive debugging experience in the face of large programs.},
booktitle = {Proceedings of the 22nd Annual ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications},
pages = {535–552},
numpages = {18},
keywords = {partial traces, omniscient debugging, specialized distributed database, scalability, interface components, execution traces},
location = {Montreal, Quebec, Canada},
series = {OOPSLA '07}
}

@article{10.1145/1297105.1297067,
author = {Pothier, Guillaume and Tanter, \'{E}ric and Piquer, Jos\'{e}},
title = {Scalable Omniscient Debugging},
year = {2007},
issue_date = {October 2007},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {42},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1297105.1297067},
doi = {10.1145/1297105.1297067},
abstract = {Omniscient debuggers make it possible to navigate backwards in time within a program execution trace, drastically improving the task of debugging complex applications. Still, they are mostly ignored in practice due to the challenges raised by the potentially huge size of the execution traces. This paper shows that omniscient debugging can be realistically realized through the use of different techniques addressing efficiency, scalability and usability. We present TOD, a portable Trace-Oriented Debugger for Java, which combines an efficient instrumentation for event generation, a specialized distributed database for scalable storage and efficient querying, support for partial traces in order to reduce the trace volume to relevant events, and innovative interface components for interactive trace navigation and analysis in the development environment. Provided a reasonable infrastructure, the performance of TOD allows a responsive debugging experience in the face of large programs.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {535–552},
numpages = {18},
keywords = {omniscient debugging, partial traces, scalability, specialized distributed database, execution traces, interface components}
}

@article{KABANOV201151,
title = {JRebel Tool Demo},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {264},
number = {4},
pages = {51-57},
year = {2011},
note = {Proceedings of the Fifth Workshop on Bytecode Semantics, Verification, Analysis and Transformation (Bytecode 2010)},
issn = {1571-0661},
doi = {https://doi.org/10.1016/j.entcs.2011.02.005},
url = {https://www.sciencedirect.com/science/article/pii/S1571066111000429},
author = {Jevgeni Kabanov},
keywords = {bytecode, JRebel, ClassLoader, API, retroactive},
abstract = {JRebel started as an academical project that became a successful commercial product used by thousands of developers worldwide. It extends the Java Virtual Machine with a mechanism that allows seamless class reloading. It uses bytecode manipulation extensively, both for the just-in-time class translator and numerous integrations with the Java SE and EE APIs. In this live demo we will show how it can be used in real-life projects to cut development time by 8 to 18 per cent.}
}
